{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Measuring quantum states in QuAIRKit\n",
    "\n",
    "This tutorial demonstrates how to perform quantum measurement using QuAIRKit.\n",
    "\n",
    "**Table of Contents**\n",
    "\n",
    "- [Quantum measurement](#Quantum-measurement)\n",
    "- [Quantum Circuit](#Quantum-circuit)\n",
    "  - [Example](#Example) \n",
    "- [Measurement](#Measurement)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import time\n",
    "import traceback\n",
    "\n",
    "import torch\n",
    "import quairkit as qkit\n",
    "from quairkit.database import *\n",
    "from quairkit.loss import Measure\n",
    "from quairkit.qinfo import prob_sample\n",
    "\n",
    "qkit.set_dtype('complex128')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Quantum measurement\n",
    "\n",
    "The idea of measurement comes from one of the four postulates in quantum machanics.\n",
    "\n",
    "> Postulate 3 [1]\n",
    ">\n",
    "> *Quantum measurement*s are described by a collection $\\{M_m\\}_m$ of measurement operators. These are operators acting on the state space of the system being measured. The index $m$ refers to the measurement outcomes that may occur in the experiment. If the state of the quantum system is $|\\psi\\rangle$ immediately before the measurement, then the probability that result $m$ occurs is given by\n",
    "> $$p(m) = \\langle\\psi|  M_m^\\dagger M_m |\\psi\\rangle$$\n",
    "> and the state of the system after the measurement is\n",
    "> $$\\frac{M_m |\\psi\\rangle}{\\sqrt{\\langle\\psi| M_m^\\dagger M_m |\\psi\\rangle}}$$\n",
    "> \n",
    "> where the measurement operators satisfy the completeness equation,\n",
    "> $$\\sum_m M_m^\\dagger M_m = I.$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Such operator set $\\{M_m^\\dagger M_m\\}_m$ is called a *Positive Operator-Valued Measure* (POVM). When all $M_m$ are orthogonal projectors  (i.e., $M_m = M_m^\\dagger = M_m^2$), this set is called a *Projection-valued Measure* (PVM). The quantum measurement described by PVM is called a *projective measurement*. \n",
    "\n",
    "We usually perform projective measurements based on the eigenbasis of an observable. For example, we can generate a PVM for the Pauli string 'x'."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[[ 0.5000+0.j,  0.5000+0.j],\n",
      "         [ 0.5000+0.j,  0.5000+0.j]],\n",
      "\n",
      "        [[ 0.5000+0.j, -0.5000+0.j],\n",
      "         [-0.5000+0.j,  0.5000+0.j]]])\n"
     ]
    }
   ],
   "source": [
    "pvm = pauli_str_povm('x')\n",
    "print(pvm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Perform measurement"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Projective measurements in QuAIRKit are mainly called by a torch Module `Measure`. There are three ways to initialize a `Measure` instance:\n",
    "\n",
    "1. Set computational measurement by default, i.e., $M_m = \\{|m\\rangle\\langle m|\\}$\n",
    "2. Set measurement by given pauli string(s)\n",
    "3. Set measurement by given PVM(s) in torch.Tensor\n",
    "\n",
    "For Measure instances initialized in the first two ways, if the measurement is across all qubits, then the output state(s) will always be recognized as pure state(s)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "op = Measure() # computational measure\n",
    "op = Measure('x') # x measure on a qubit\n",
    "op = Measure(pvm) # measure with a pvm"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Measure accepts the `State` instances and an (optional) measure position as input and returns the measurement result. Note that if measure only happens on a part of the system, then the argument `qubits_idx` should be specified."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The probability distribution is stored in shape torch.Size([2])\n"
     ]
    }
   ],
   "source": [
    "num_qubits = 1\n",
    "rho = random_state(num_qubits, rank=2)\n",
    "\n",
    "prob = op(rho, qubits_idx=[0]) # measure rho\n",
    "print('The probability distribution is stored in shape', prob.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Measure can retain the collapsed state after measurement by setting `keep_state = True`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The collapsed state for each outcome is \n",
      "---------------------------------------------------\n",
      " Backend: density_matrix\n",
      " System dimension: [2]\n",
      " System sequence: [0]\n",
      " Batch size: [2]\n",
      "\n",
      " # 0:\n",
      "[[0.5+0.j 0.5+0.j]\n",
      " [0.5+0.j 0.5+0.j]]\n",
      " # 1:\n",
      "[[ 0.5+0.j -0.5+0.j]\n",
      " [-0.5+0.j  0.5+0.j]]\n",
      "---------------------------------------------------\n",
      "\n"
     ]
    }
   ],
   "source": [
    "prob, collapsed_state = op(rho, keep_state=True)\n",
    "print('The collapsed state for each outcome is', collapsed_state)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Measure can only return the particular measurement outcome by setting `desired_result=x`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The probability for obtaining outcome 1 is tensor([0.2544]), with outcome state \n",
      "---------------------------------------------------\n",
      " Backend: density_matrix\n",
      " System dimension: [2]\n",
      " System sequence: [0]\n",
      " Batch size: [1]\n",
      "\n",
      " # 0:\n",
      "[[ 0.5+0.j -0.5+0.j]\n",
      " [-0.5+0.j  0.5+0.j]]\n",
      "---------------------------------------------------\n",
      "\n"
     ]
    }
   ],
   "source": [
    "x = '1'\n",
    "prob, collapsed_state = op(rho, keep_state=True, desired_result=x) # return the second outcome\n",
    "print(f'The probability for obtaining outcome {x} is {prob}, with outcome state', collapsed_state)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can also directly call the attribute `measure` of `State` instances for simple measurement."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "prob = rho.measure(pvm) # same as Measure(pvm)(rho)\n",
    "prob, collapsed_state = rho.measure(pvm, keep_state=True) # same as Measure(pvm)(rho, keep_state=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Positive operator-valued measurement"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "POVM is a generalization of PVM, yet it may be non-physical. In QuAIRKit, we can perform positive operator-valued measurement by  `State.measure`, with `is_povm` set to True.\n",
    "\n",
    "Computation for POVM is often more efficient than that for PVM, as it directly computes the probability. However, its potentially lack of a unique post-measurement state makes it less useful in practice."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Time for measuring with pvm: 0.0005207062s\n",
      "Time for measuring with povm: 0.0003004074s\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Traceback (most recent call last):\n",
      "  File \"/tmp/ipykernel_70098/889726792.py\", line 11, in <module>\n",
      "    rho.measure(pvm, is_povm=True, keep_state=True)\n",
      "  File \"/home/leiz/QuAIRKit-Dev/quairkit/core/state/backend/__init__.py\", line 604, in measure\n",
      "    raise ValueError(\n",
      "ValueError: `is_povm` and `keep_state` cannot be both True, since a general POVM does not distinguish states.\n"
     ]
    }
   ],
   "source": [
    "start_time = time.time()\n",
    "prob = rho.measure(pvm)\n",
    "print(f'Time for measuring with pvm: {time.time() - start_time:.10f}s')\n",
    "\n",
    "\n",
    "start_time = time.time()\n",
    "prob = rho.measure(pvm, is_povm=True)\n",
    "print(f'Time for measuring with povm: {time.time() - start_time:.10f}s')\n",
    "\n",
    "try:\n",
    "    rho.measure(pvm, is_povm=True, keep_state=True)\n",
    "except ValueError:\n",
    "    traceback.print_exc()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Batch Measurement"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "QuAIRKit supports batched measurement under broadcasting rule, either one or multiple PVMs, or one or multiple input states, or both. The broadcasting rule is summarized as follows:\n",
    "\n",
    "|    PVM of size m    |     State      |  Probability       |\n",
    "|:----------------:|:---------------------:|:---------------------:|\n",
    "| [None, ...]   | [None, ...] | [m] |\n",
    "| [None, ...] | [n, ...]       | [n, m] |\n",
    "| [n, ...] | [None, ...]       | [n, m] |\n",
    "| [n, ...] | [n, ...]       | [n, m] |\n",
    "| [n, ...] | [p, ...]       | Error |\n",
    "\n",
    "Here the first dimension indicates the batch size of PVMs and input states."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can initialize a batch Measure instance via Pauli string, or directly input the batched PVM in torch.Tensor."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([3, 2, 2, 2])\n"
     ]
    }
   ],
   "source": [
    "batch_size = 3\n",
    "\n",
    "op = Measure(['x', 'y', 'z']) # measure states by x, y, z basis, respectively\n",
    "\n",
    "list_pvm = pauli_str_povm(['x', 'y', 'z'])\n",
    "print(list_pvm.shape)\n",
    "op = Measure(list_pvm) # equivalent to Measure(['x', 'y', 'z'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As shown by above table, you can apply `Measure` to a single state"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The measured states for the first batch is \n",
      "---------------------------------------------------\n",
      " Backend: density_matrix\n",
      " System dimension: [2]\n",
      " System sequence: [0]\n",
      " Batch size: [2]\n",
      "\n",
      " # 0:\n",
      "[[0.5+0.j 0.5+0.j]\n",
      " [0.5+0.j 0.5+0.j]]\n",
      " # 1:\n",
      "[[ 0.5+0.j -0.5+0.j]\n",
      " [-0.5+0.j  0.5+0.j]]\n",
      "---------------------------------------------------\n",
      " with prob distribution tensor([0.7456, 0.2544])\n"
     ]
    }
   ],
   "source": [
    "prob, collapsed_state = op(rho, keep_state=True)\n",
    "print('The measured states for the first batch is', collapsed_state[0],\n",
    "      f'with prob distribution {prob[0]}')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "or apply `Measure` to a batched state. Note that the batch dimension need to be matched."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The measured states for the first batch is \n",
      "---------------------------------------------------\n",
      " Backend: state_vector\n",
      " System dimension: [2]\n",
      " System sequence: [0]\n",
      " Batch size: [2]\n",
      "\n",
      " # 0:\n",
      "[0.58-0.4j 0.58-0.4j]\n",
      " # 1:\n",
      "[-0.06+0.7j  0.06-0.7j]\n",
      "---------------------------------------------------\n",
      " with prob distribution tensor([0.9872, 0.0128])\n"
     ]
    }
   ],
   "source": [
    "list_rho = random_state(num_qubits, size=batch_size)\n",
    "\n",
    "prob, collapsed_state = op(list_rho, keep_state=True)\n",
    "print('The measured states for the first batch is', collapsed_state[0],\n",
    "      f'with prob distribution {prob[0]}')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Sampled measurements\n",
    "\n",
    "You can use `quairkit.qinfo.prob_sample` to generate shots of qubits measured based on given probability distributions.\n",
    "\n",
    "For example, in 1024 shots, `'00': tensor([98, ...])` indicates 98 occurrences for measuring 00 in the first probability distribution, and so on. You can also adjust the argument `binary` and `proportional` to change the output format:\n",
    "\n",
    "- `binary` is False: the dictionary index is in the decimal system. \n",
    "- `proportional` is True: values are transformed into proportions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3 probability distributions are\n",
      " tensor([[0.9872, 0.0128],\n",
      "        [0.8805, 0.1195],\n",
      "        [0.8752, 0.1248]])\n",
      "{'0': tensor([1018,  893,  903]), '1': tensor([  6, 131, 121])}\n",
      "{'0': tensor([1019,  893,  884]), '1': tensor([  5, 131, 140])}\n",
      "{'0': tensor([0.9932, 0.8848, 0.8633]), '1': tensor([0.0068, 0.1152, 0.1367])}\n"
     ]
    }
   ],
   "source": [
    "print(f'{batch_size} probability distributions are\\n', prob)\n",
    "\n",
    "print(prob_sample(prob))\n",
    "print(prob_sample(prob, binary=False))\n",
    "print(prob_sample(prob, proportional=True))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "\n",
    "## References\n",
    "\n",
    "[1] Nielsen, Michael A., and Isaac L. Chuang. Quantum computation and quantum information. Vol. 2. Cambridge: Cambridge university press, 2001."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "quairkit",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
